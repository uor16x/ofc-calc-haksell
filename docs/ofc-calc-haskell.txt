-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package ofc-calc-haskell
@version 0.1.0.0


-- | Card suit data type and its processing functions
module CardParts.Suits

-- | This type represents card suit.
data Suit
Hearts :: Suit
Diamonds :: Suit
Clubs :: Suit
Spades :: Suit

-- | This function gets a char which represents card suit and returns a
--   <a>Suit</a> wrapped with <a>Right</a>.
--   
--   Char should be a lowercase symbol from "hdcs" list. Otherwise -
--   <a>Left</a> with err msg returns.
--   
--   <b>Examples:</b>
--   
--   <pre>
--   parseSuit 'h' = <a>Right</a> <a>Hearts</a>
--   parseSuit 'c' = <a>Right</a> <a>Clubs</a>
--   parseSuit 'x' = <a>Left</a> "There is no card suit marked as <tt>x</tt>"
--   </pre>
parseSuit :: Char -> Either String Suit
instance GHC.Generics.Generic CardParts.Suits.Suit
instance GHC.Enum.Bounded CardParts.Suits.Suit
instance GHC.Enum.Enum CardParts.Suits.Suit
instance GHC.Show.Show CardParts.Suits.Suit
instance GHC.Classes.Eq CardParts.Suits.Suit
instance Data.Aeson.Types.FromJSON.FromJSON CardParts.Suits.Suit
instance Data.Aeson.Types.ToJSON.ToJSON CardParts.Suits.Suit


-- | Card value data type and its processing functions
module CardParts.Values

-- | This type represents card value.
data Value
Two :: Value
Three :: Value
Four :: Value
Five :: Value
Six :: Value
Seven :: Value
Eight :: Value
Nine :: Value
Ten :: Value
Jack :: Value
Queen :: Value
King :: Value
Ace :: Value

-- | This function gets a char which represents card value and returns a
--   <a>Value</a> wrapped with <a>Maybe</a>.
--   
--   Char should be a digit between 2 and 9 or an uppercase symbol from
--   [AKQJT] list. Otherwise - <a>Nothing</a> returns.
--   
--   <b>Examples:</b>
--   
--   <pre>
--   parseValue '2' = <a>Right</a> <a>Two</a>
--   parseValue 'Q' = <a>Right</a> <a>Queen</a>
--   parseValue 'z' = <a>Left</a> "There is no broadway card, which could be represented with 'z'"
--   parseValue '1' = <a>Left</a> "There is no number card with value 1"
--   </pre>
parseValue :: Char -> ValueResult
instance GHC.Generics.Generic CardParts.Values.Value
instance GHC.Enum.Bounded CardParts.Values.Value
instance GHC.Classes.Ord CardParts.Values.Value
instance GHC.Enum.Enum CardParts.Values.Value
instance GHC.Classes.Eq CardParts.Values.Value
instance GHC.Show.Show CardParts.Values.Value
instance Data.Aeson.Types.FromJSON.FromJSON CardParts.Values.Value
instance Data.Aeson.Types.ToJSON.ToJSON CardParts.Values.Value


-- | Combined (value + suit) card data type and its processing functions
module CardParts.Cards

-- | This type represents a card - combination of suit and value.
data Card
Card :: Value -> Suit -> Card
[value] :: Card -> Value
[suit] :: Card -> Suit

-- | This function gets a string which represents full card combination
--   (value + suit) and returns a <a>Card</a> wrapped with <a>Right</a>.
--   The function uses <a>parseValue</a> and <a>parseSuit</a> functions.
--   
--   Passed string should have length 2 and have format "{VALUE}{SUIT}".
--   
--   <b>Examples:</b>
--   
--   <pre>
--   parseCard "2c" = <a>Right</a> <a>Two</a> <a>Clubs</a>
--   parseCard "As" = <a>Right</a> <a>Ace</a> <a>Spades</a>
--   parseCard "" = <a>Left</a> "Can't process emtpy string"
--   parseCard "22c" = <a>Left</a> "Argument length should be 2"
--   parseCard <a>Zd</a> = <a>Left</a> "There is no broadway card, which could be represented with 'Z'"
--   parseCard "5f" = <a>Left</a> "There is no card suit marked as 'f'"
--   parseCard "2x" = <a>Left</a> "There is no card suit marked as 'x'"
--   </pre>
parseCard :: String -> Either String Card
instance GHC.Generics.Generic CardParts.Cards.Card
instance GHC.Show.Show CardParts.Cards.Card
instance Data.Aeson.Types.FromJSON.FromJSON CardParts.Cards.Card
instance Data.Aeson.Types.ToJSON.ToJSON CardParts.Cards.Card
instance GHC.Classes.Eq CardParts.Cards.Card
instance GHC.Classes.Ord CardParts.Cards.Card


-- | User board and its processing functions
module Game.Board

-- | Parsed card result wrapper which also holds the possible err msg
type CardParseResult = Either String Card

-- | Shorthand for board type
type Board = [[Card]]

-- | This function gets a list of strings which items represents a card
--   notation. Returns <a>Either</a> type, where <a>Left</a> is
--   <a>String</a> with error message, and <a>Right</a> is <a>Board</a>
--   type. Processes only list of length 13. Method is going to fail the
--   list with duplicates.
--   
--   <b>Examples:</b>
--   
--   <pre>
--   cards = [
--       "Ah", "Qd", "Kc",
--       "Ts", "Jc", "6h", "2h", "3h",
--       "8c", "4c", "7s", "9c", "Tc"
--   ]
--   getUserBoard cards = <a>Right</a> [
--       [
--           <a>Card</a> {value = Ace, suit = Hearts},
--           <a>Card</a> {value = Queen, suit = Diamonds},
--           <a>Card</a> {value = King, suit = Clubs}
--       ],
--       [
--           <a>Card</a> {value = Ten, suit = Spades},
--           <a>Card</a> {value = Jack, suit = Clubs},
--           <a>Card</a> {value = Six, suit = Hearts},
--           <a>Card</a> {value = Two, suit = Hearts},
--           <a>Card</a> {value = Three, suit = Hearts}
--       ],
--       [
--           <a>Card</a> {value = Eight, suit = Clubs},
--           <a>Card</a> {value = Four, suit = Clubs},
--           <a>Card</a> {value = Seven, suit = Spades},
--           <a>Card</a> {value = Nine, suit = Clubs},
--           <a>Card</a> {value = Ten, suit = Clubs}
--       ]
--   ]
--   
--   cardsTwo = [
--       "Az", "Qx", "Kf",
--       "Xs", "Jc", "6h", "2h", "3h",
--       "8c", "4c", "7s", "9c", "Tc"
--   ]
--   getUserBoard cardsTwo = <a>Left</a>
--       "Some cards failed to be parsed:
--       There is no card suit marked as 'z';
--       There is no card suit marked as 'x';
--       There is no card suit marked as 'f';
--       There is no broadway card, which could be represented with 'X';"
--   </pre>
getUserBoard :: [String] -> Either String Board


-- | Poker combination and its processing functions
module Game.Combination

-- | This type represents a poker combination. | It is divided by two
--   constructors: for simple combinations (pair, set etc.) | and for
--   combinations with multiple items (two pairs, full house)
data Combination
RankCombination :: CombinationName -> Card -> Combination
[name] :: Combination -> CombinationName
[rank] :: Combination -> Card
PartCombination :: CombinationName -> Card -> Card -> Combination
[name] :: Combination -> CombinationName
[part1] :: Combination -> Card
[part2] :: Combination -> Card

-- | This function gets a list of cards and returns a list of tuples. First
--   element of which contains certain card, and second element contains
--   number of occurences.
--   
--   Function takes the head of the list and search for occurrences of its
--   card in the tail. Then, recursively calls itself for tail with that
--   card removed from it.
--   
--   <b>Examples:</b>
--   
--   <pre>
--   getOccurrences [
--       <a>Card</a> {value = <a>Ace</a>, suit = <a>Spades</a>},
--       <a>Card</a> {value = <a>Jack</a>, suit = <a>Clubs</a>},
--       <a>Card</a> {value = <a>Ace</a>, suit = 'Hearts}
--   ] = [(Card {value = Ace, suit = Spades},2),(Card {value = Jack, suit = Clubs},1)]
--   </pre>
getOccurrences :: [Card] -> OccurrencesCounter

-- | This function parses sequences in cards line returns a combination,
--   wrapped with <a>Right</a>, or string err msg wrapped with <a>Left</a>.
--   The input is list of cards - [<a>Card</a>]. <b>Examples:</b>
--   
--   <pre>
--   parseSequence [
--       (<a>Card</a> {value = <a>Ace</a>, suit = <a>Spades</a>}, 2),
--       (<a>Card</a> {value = <a>King</a>, suit = <a>Clubs</a>}, 2)
--   ] = <a>Right</a> <a>PartCombination</a> <a>TwoPairs</a> (<a>Card</a> {value = <a>Ace</a>, suit = <a>Spades</a>) (<a>Card</a> {value = <a>King</a>, suit = <a>Clubs</a>})
--   </pre>
parseSequence :: [Card] -> Either String Combination

-- | This function parses occurences data and returns a combination,
--   wrapped with <a>Right</a>, or string err msg wrapped with <a>Left</a>.
--   The input is list of tuples - [(<a>Card</a>, <a>Int</a>)], where first
--   element is a card and seconds is number of its occurrences.
--   <b>Examples:</b>
--   
--   <pre>
--   parsePartHand [
--        <a>Card</a> {value = <a>Ace</a>, suit = <a>Spades</a>},
--       <a>Card</a> {value = <a>Jack</a>, suit = <a>Clubs</a>},
--       <a>Card</a> {value = <a>Ten</a>, suit = <a>Clubs</a>},
--       <a>Card</a> {value = <a>Queen</a>, suit = 'Hearts},
--       <a>Card</a> {value = <a>King</a>, suit = 'Hearts},
--   ] = <a>Right</a> <a>RankCombination</a> <a>Straight</a> <a>Card</a> {value = <a>Ace</a>, suit = <a>Spades</a>}
--   </pre>
parsePartHand :: OccurrencesCounter -> Either String Combination
parseCombination :: [Card] -> Either String Combination

-- | Names of combinations enum
data CombinationName
Kicker :: CombinationName
Pair :: CombinationName
TwoPairs :: CombinationName
Set :: CombinationName
Straight :: CombinationName
Flush :: CombinationName
FullHouse :: CombinationName
FourOfAKind :: CombinationName
StraightFlush :: CombinationName
RoyalFlush :: CombinationName
instance GHC.Generics.Generic Game.Combination.CombinationName
instance GHC.Enum.Enum Game.Combination.CombinationName
instance GHC.Enum.Bounded Game.Combination.CombinationName
instance GHC.Classes.Ord Game.Combination.CombinationName
instance GHC.Classes.Eq Game.Combination.CombinationName
instance GHC.Show.Show Game.Combination.CombinationName
instance GHC.Generics.Generic Game.Combination.Combination
instance GHC.Show.Show Game.Combination.Combination
instance Data.Aeson.Types.FromJSON.FromJSON Game.Combination.Combination
instance Data.Aeson.Types.ToJSON.ToJSON Game.Combination.Combination
instance GHC.Classes.Eq Game.Combination.Combination
instance GHC.Classes.Ord Game.Combination.Combination
instance Data.Aeson.Types.FromJSON.FromJSON Game.Combination.CombinationName
instance Data.Aeson.Types.ToJSON.ToJSON Game.Combination.CombinationName


-- | Game calculations and its processing functions
module Game.Calc
data PlayerInput
PlayerInput :: String -> [Combination] -> Bool -> Bool -> PlayerInput
[username] :: PlayerInput -> String
[board] :: PlayerInput -> [Combination]
[scoop] :: PlayerInput -> Bool
[withFantasy] :: PlayerInput -> Bool

-- | Data container for line result for the user.
--   
--   Contains data about type of line (position - top<i>middle</i>bottom),
--   about points for the combination, total values for combo/bonus points
--   after comparison with others.
data LineResult
data LineType
Top :: LineType
Middle :: LineType
Bottom :: LineType

-- | Container for result of calculations for each player.
--   
--   Contains data about given player input, description of each line in
--   form of <a>LineResult</a>, some utility bool values, such as
--   <a>isScoop</a>, <a>isNextFantasy</a>. Also has total sum of points for
--   user after comparison. And a debug detailed version of the total
--   (totalDetailed field).
data PlayerCalculations
PlayerCalculations :: PlayerInput -> LineResult -> LineResult -> LineResult -> Bool -> Bool -> (String, [LineCompareResult]) -> Int -> PlayerCalculations
[player] :: PlayerCalculations -> PlayerInput
[top] :: PlayerCalculations -> LineResult
[middle] :: PlayerCalculations -> LineResult
[bottom] :: PlayerCalculations -> LineResult
[isScoop] :: PlayerCalculations -> Bool
[isNextFantasy] :: PlayerCalculations -> Bool
[totalDetailed] :: PlayerCalculations -> (String, [LineCompareResult])
[total] :: PlayerCalculations -> Int

-- | Function to compare <a>PlayerInput</a> records and retrieve calculated
--   points. Takes two <a>PlayerInput</a> as input. Returns calculated
--   points in form of <a>LineCompareResult</a>
comparePlayers :: PlayerInput -> PlayerInput -> LineCompareResult

-- | Main function for game calculation.
--   
--   Takes a list of 'PlayerInput;, which length should be 3. Return a list
--   of <a>PlayerCalculations</a>.
--   
--   First of all, function receives all players comparison using
--   <a>collectLinesResults</a>. Then it checks for input conditions:
--   length of input and length of comparison results should be equal and
--   should equal 3.
--   
--   Then for each of player input function creates
--   <a>PlayerCalculations</a> record.
calcGame :: [PlayerInput] -> [PlayerCalculations]
instance GHC.Generics.Generic Game.Calc.PlayerInput
instance GHC.Show.Show Game.Calc.PlayerInput
instance GHC.Generics.Generic Game.Calc.LineType
instance GHC.Show.Show Game.Calc.LineType
instance GHC.Generics.Generic Game.Calc.LineResult
instance GHC.Show.Show Game.Calc.LineResult
instance GHC.Generics.Generic Game.Calc.PlayerCalculations
instance Data.Aeson.Types.FromJSON.FromJSON Game.Calc.PlayerCalculations
instance Data.Aeson.Types.ToJSON.ToJSON Game.Calc.PlayerCalculations
instance Data.Aeson.Types.FromJSON.FromJSON Game.Calc.LineResult
instance Data.Aeson.Types.ToJSON.ToJSON Game.Calc.LineResult
instance Data.Aeson.Types.FromJSON.FromJSON Game.Calc.LineType
instance Data.Aeson.Types.ToJSON.ToJSON Game.Calc.LineType
instance Data.Aeson.Types.FromJSON.FromJSON Game.Calc.PlayerInput
instance Data.Aeson.Types.ToJSON.ToJSON Game.Calc.PlayerInput

module OfcCalc
